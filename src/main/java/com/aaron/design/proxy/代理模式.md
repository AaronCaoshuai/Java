[TOC]



# 代理模式

## 目的

 提供了对目标对象另外的访问方式;即通过代理对象访问目标对象.这样做的好处是:可以在目标对象实现的基础上,增强额外的功能操作,即扩展目标对象的功能.
这里使用到编程中的一个思想:不要随意去修改别人已经写好的代码或者方法,如果需改修改,可以通过代理的方式来扩展该方法  

## 角色

目标对象:需要被代理的对象

代理对象:通过代理对象对目标对象进行一些处理

客户:通过使用代理对象来完成对目标对象的调用

## 使用场景

- **远程代理** ：为位于两个不同地址空间对象的访问提供了一种实现机制，可以将一些消耗资源较多的对象和操作移至性能更好的计算机上，提高系统的整体运行效率。

- **虚拟代理**：通过一个消耗资源较少的对象来代表一个消耗资源较多的对象，可以在一定程度上节省系统的运行开销。

- **缓冲代理**：为某一个操作的结果提供临时的缓存存储空间，以便在后续使用中能够共享这些结果，优化系统性能，缩短执行时间。

- **保护代理**：可以控制对一个对象的访问权限，为不同用户提供不同级别的使用权限。

- **智能引用**：要为一个对象的访问（引用）提供一些额外的操作时可以使用

  以上内容: 过太抽象,暂时可以不要在意,随着你的不断进步你终究会明白的 

举例:

​	远程调用 java RMI

​	Spring AOP使用动态代理(智能引用)

​	虚拟代理 对于某些耗时的操作 比如:Mybatis中的侵入式加载功能,可以预先获取代理对象,但是不执行数据库查询操作,对于需要进行查询操作的时候,在进行数据库查询.

​	Mybatis打印jdbc执行日志的时候用到JDK动态代理模式.

## 静态代理

 静态代理是指预先确定了代理与被代理者的关系,需要编写代理类,进行编译运行.

 静态代理在使用时,需要定义接口或者父类,被代理对象与代理对象一起实现相同的接口或者是继承相同父类. 

可以做到在不修改目标对象的功能前提下,对目标功能扩展.

## 动态代理

 动态代理本质上仍然是代理，情况与上面介绍的完全一样，只是代理与被代理人的关系是动态确定的 

 1.代理对象,不需要实现接口
 2.代理对象的生成,是利用JDK的API,动态的在内存中构建代理对象(需要我们指定创建代理对象/目标对象实现的接口的类型)
 3.动态代理也叫做:JDK代理,接口代理 对于没有接口的对象我们可以使用cglib动态代理

JDK动态代理:对于方法是依赖于接口目标类,使用JDK动态代理

1.代理类需要实现java.lang.reflect.InvocationHandler

2.重写invoke(Object proxy,Method method,Object args[]) 

3.持有目标对象的引用

4.获取代理对象java.lang.reflect.Proxy.newProxyInstance(ClassLoader loader,Class<?>[] interfaces,                                     InvocationHandler h);

执行原理:

​	调用Proxy.newProxyInstance方法,获取代理类(具体应用到反射的一些操作,来对代理类进行实例化)

​	代理类是继承了Proxy代理对象,并且实现了目标对象的接口的.

​	其中包括了Object类的方法和实现的目标对象的方法,以及对于InvocationHandler对象的引用和目标对象Method的引用,

​	随后调用目标对象的方法,实际调用的是InvocationHandler的Invoke方法.

​	invoke方法是具体的目标对象的方法的增强实现和控制实现.

CgLib动态代理

​	使用字节码技术实现动态代理,通过字节码技术为目标类生成一个子类,并在该子类中采用方法拦截的方式拦截所有父类方法的调用,从而实现代理的功能.因为cglib使用生成子类的方式实现动态代理,所以无法代理final关键字修饰的方法,cglib与Jdk动态代理之间可以互相补充:在目标类实现接口时,使用JDK动态代理创建代理对象,但当目标类没有实现接口时,使用cglib实现动态代理的功能,在spring,mybatis的多种开源框架中,都可以看到JDK动态代理与cglib结合使用的场景.

​	1.需要定义一个Callback接口的实现,cglib中提供了多个Callback接口的子接口例如:MethodInterceptor

​	2.实现接口,例如:实现MethodInterceptor  引用Enhancer对象,Enhancer对象指定生成的代理类的父类,设置Callback对象,通过字节码技术动态创建子类实例

​	3.实现MethodInterceptor接口的intercept()方法,对目标对象的方法进行增强.

​	CgLib使用的是ASM实现的

​	字节码技术:参考javaSE-字节码技术

静态代理和动态代理的比较

静态代理:因为代理对象需要与目标对象实现一样的接口,所以会有很多代理类,类太多.同时,一旦接口增加方法,目标对象与代理对象都要维护.

动态代理: 动态代理可以在程序运行期间根据需要动态的创建代理类及其实例来完成具体的功能,解决了静态代理需要创建大量的代理类的重复编码过程.



## 总结

静态代理是通过在代码中显式定义一个业务实现类一个代理,在代理类中对同名的业务方法进行包装.用户通过代理类调用包装过的业务方法;

jdk动态代理是通过接口中的方法名,在动态生成的代理类中调用业务实现类的同名方法

CGlib动态代理是通过继承业务类,生成的动态代理类是业务类的子类,通过重写业务方法进行代理