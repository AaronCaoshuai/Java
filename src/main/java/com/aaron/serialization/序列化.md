# 序列化

序列化:将对象写入到IO流中

反序列化:从IO流中恢复对象

## 序列化意义

序列化机制允许将实现序列化的java对象转换为字节序列,这些字节序列可以保存到磁盘上,或通过网络传输,以到达以后恢复成原来对象的目的.序列化机制使得对象可以脱离程序的运行而独立存在.

## 应用场景

所有可在网络上传输的对象都必须是可序列化的,比如RMI,远程方法调用,传入的参数或返回的对象都是可序列化的,否则会出错,所有需要保存到磁盘的java对象都必须是可序列化的,通常建议:程序创建的每个JavaBean类都实现Serializable接口.

## 序列化实现方式

### 普通序列化:

1.Serializable接口是一个标记接口,不用实现任何方法,一旦实现了此接口,该类的对象就是可序列化的. Serializable接口就是Java提供用来进行高效率的异地共享实例对象的机制，实现这个接口即可 

序列化步骤:

1.创建一个ObjectOutputStream输出流;

2.调用ObjectOutputStream对象的writeObject输出可序列化对象

反序列化步骤:

1.创建一个ObjectInputStream输入流;

2.调用ObjectInputStream对象的readObject得到序列化的对象

注意: 

**反序列化并不会调用构造方法。反序列的对象是由JVM自己生成的对象，不通过构造方法生成。** 

##### 成员是引用的序列化

**如果一个可序列化的类的成员不是基本类型，也不是String类型，那这个引用类型也必须是可序列化的；否则，会导致此类不能序列化。**

同一对象序列化多次的机制, **Java序列化同一对象，并不会将此对象序列化多次得到多个对象** 

**反序列化的顺序与序列化时的顺序一致** 

序列化算法:

1.所有保存到磁盘的对象都有一个序列化编号

2.当程序试图序列化一个对象时,会先检查此对象是否已经序列化过,只有此对象从未(在此虚拟机)被序列化过,才会将此对象序列化为字节序列输出

3.如果此对象已经序列化过,则直接输出编号即可.

潜在问题:

 由于java序利化算法不会重复序列化同一个对象，只会记录已序列化对象的编号。**如果序列化一个可变对象（对象内的内容可更改）后，更改了对象内容，再次序列化，并不会再次将此对象转换为字节序列，而只是保存序列化编号。** 

这样的话某些对象的比较判断就是错误的了.



## 可选自定义序列化

对于某些不需要序列化的属性,使用transient关键字选择不需要序列化的字段.

 **使用transient修饰的属性，java序列化时，会忽略掉此字段，所以反序列化出的对象，被transient修饰的属性是默认值。对于引用类型，值是null；基本类型，值是0；boolean类型，值是false。** 

 1) Serializable作为标记接口其实还有除了readObject和writeObject之外的其它标记接口方法；

  2) 这里介绍的方法专门用来解决反序列化异常问题，需要自己实现：private void readObjectNoData() throws ObjectStreamException;

  3) 当反序列化是遇到如下异常会自动调用该方法：

​     i. 序列化版本不兼容；

​     ii. 输入流被篡改或者损坏；

！！该方法的目的就是在发生上面这些异常时给对象提供一个合理的值（比如默认值或者全是0、null之类的，视具体情况而定）；

！！但是如果泛序列化时接受的类程序中不存在还是会抛出异常的，毕竟该方法最终还是会还原出一个对象来，而对象的存在是以类的存在位前提的，所以没有类还是不行的！



3. 写入时替换对象——writeReplace：

  1) Serializable还有两个标记接口方法可以实现序列化对象的替换，即writeReplace和readResolve；

！！writeReplace的原型：任意访问限定符 Object writeReplace() throws ObjectStreamException;

  2) 如果实现了writeReplace方法后，那么在序列化时会先调用writeReplace方法将当前对象替换成另一个对象（该方法会返回替换后的对象）并将其写入流中

 a. 实现writeReplace就不要实现writeObject了，因为writeReplace的返回值会被自动写入输出流中，就相当于自动这样调用：writeObject(writeReplace());

​      b. 因此writeReplace的返回值（对象）必须是可序列话的，如果是Java自己的基础类或者类型那就不用说了；

​      c. 但如果返回的是自定义类型的对象，那么该类型必须是彻底实现序列化的！

  3) writeReplace的替换如何在反序列化时被恢复？

​     i. 注意！不是用readResolve恢复哦！readResolve并不是用来恢复writeReplace的！

​     ii. 这里无法恢复了！即对象被彻底替换了！也就是说使用ObjectInputStream读取的对象只能是被替换后的对象，只能在读取后自己手动恢复了

 因此得到一个结论，那就是writeObject只和readObject配合使用，一旦实现了writeReplace在写入时进行替换就不再需要writeObject和readObject了！因为替换就已经是彻底的自定义了，比writeObject/readObject更彻底！ 

\4. 保护性恢复对象（同时也可以替换对象）——readResolve：

  1) readResolve会在readObject调用之后自动调用，它最主要的目的就是让恢复的对象变个样，比如readObject已经反序列化好了一个Person对象，那么就可以在readResolve里再对该对象进行一定的修改，而最终修改后的结果将作为ObjectInputStream的readObject的返回结果；

  2) 原型：任意访问限定符 Object readResolve() throws ObjectStreamException;

  3) 该方法起到的作用：

​     i. 调用该方法之前会先调用readObject反序列化得到对象；

​     ii. 接着，如果该方法存在则会自动调用该方法；

​     iii. 在该方法中可以正常通过this访问到刚才反序列化得到的对象的内容；

​     iv. 然后可以根据这些内容进行一定处理返回一个对象；

​     vi. 该对象将作为ObjectInputStream的readObject的返回值（即该对象将作为对象输入流的最终输入）；

readResolve的最主要应用场合就是单例、枚举类型的保护性恢复！

！！当然自己手动实现的单例、枚举类型要串行化是必须要实现readResolve的保护性恢复的，但是如果使用Java的enum关键字来定义枚举类型则不需要了（Java 5之后的版本都实现了enum类型的自动保护性恢复，但是Java 5之前的老版本还是不行！）；

### 强制自定义序列化

通过实现Externalizable接口,必须实现writeExternal方法 序列化 自定义序列化的方式,readExternal方法 反序列化 需要遵循序列化方式进行反序列化

 **Externalizable接口不同于Serializable接口，实现此接口必须实现接口中的两个方法实现自定义序列化，这是强制性的；特别之处是必须提供pulic的无参构造器，因为在反序列化的时候需要反射创建对象。** 



### 两种序列化对比

| 实现Serializable接口                                         | 实现Externalizable接口   |
| :----------------------------------------------------------- | :----------------------- |
| 系统自动存储必要的信息                                       | 程序员决定存储哪些信息   |
| Java内建支持，易于实现，只需要实现该接口即可，无需任何代码支持 | 必须实现接口内的两个方法 |
| 性能略差                                                     | 性能略好                 |

**虽然Externalizable接口带来了一定的性能提升，但变成复杂度也提高了，所以一般通过实现Serializable接口进行序列化。**

## 序列化版本号serialVersionUID

反序列化必须拥有class文件,但随着项目的升级,class文件也会升级,序列化怎么保证升级前后的兼容性.

java序列化提供了一个private static final long serialVersionUID 的序列化版本号,只有版本号相同,即使更好了序列化属性,对象也可以正确的被反序列化回来.

 **序列化版本号可自由指定，如果不指定，JVM会根据类信息自己计算一个版本号，这样随着class的升级，就无法正确反序列化；不指定版本号另一个明显隐患是，不利于jvm间的移植，可能class文件没有更改，但不同jvm可能计算的规则不一样，这样也会导致无法反序列化** 

- 如果只是修改了方法，反序列化不容影响，则无需修改版本号；
- 如果只是修改了静态变量，瞬态变量（transient修饰的变量），反序列化不受影响，无需修改版本号；
- 如果修改了非瞬态变量，则可能导致反序列化失败。**如果新类中实例变量的类型与序列化时类的类型不一致，则会反序列化失败，这时候需要更改serialVersionUID。**如果只是新增了实例变量，则反序列化回来新增的是默认值；如果减少了实例变量，反序列化时会忽略掉减少的实例变量。

## 总结

1. 所有需要网络传输的对象都需要实现序列化接口，通过建议所有的javaBean都实现Serializable接口。
2. 对象的类名、实例变量（包括基本类型，数组，对其他对象的引用）都会被序列化；方法、类变量、transient实例变量都不会被序列化。
3. 如果想让某个变量不被序列化，使用transient修饰。
4. 序列化对象的引用类型成员变量，也必须是可序列化的，否则，会报错。
5. 反序列化时必须有序列化对象的class文件。
6. 当通过文件、网络来读取序列化后的对象时，必须按照实际写入的顺序读取。
7. **单例类序列化，需要重写readResolve()方法；否则会破坏单例原则。**
8. 同一对象序列化多次，只有第一次序列化为二进制流，以后都只是保存序列化编号，不会重复序列化。
9. 建议所有可序列化的类加上serialVersionUID 版本号，方便项目升级。